---
typora-root-url: git\note\images.assets.assets
---

## 操作系统概述

### 操作系统

#### 作用

+ 控制和管理整个计算机系统的硬件和软件资源
+ 合理的组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境

#### 特征

+ 并发（宏观同时，微观交替；与并行的真正同时发生不同）
+ 共享（系统资源供进程同时使用，互斥共享和同时（扬声器同时，文件交替使用）共享）
+ 虚拟（物理实体分配为若干个逻辑的对应物，空分复用技术和时分复用）
+ 异步（多个进程由于资源有限不是执行到底，而是走走停停，以不可预期的速度推进）
+ 总：并发和共享是最基本的两个特征，而并发和共享互为存在条件

#### 运行机制和体系

+ CPU拥有两种状态：用户态和核心态
+ 核心态既可以运行特权指令和非特权指令，而用户态只能运行非特权指令
+ 需要特权指令的程序叫内核程序，其他被称为应用程序
+ 内核可以分成时钟管理、中断处理、原语（设备驱动、CPU切换）和系统资源的管理（进程管理、存储器管理、设备管理）
+ 大内核和微内核：系统资源的管理在内核中叫大内核，不然叫小内核

#### 系统调用

+ 系统调用是操作系统提供给应用程序使用的接口，用来请求获得操作系统的服务，操作系统通过系统调用来控制与管理资源
+ 系统调用一般是为操作系统的功能，所以系统调用的相关处理在核心态进行，**系统调用使CPU从用户态进入核心态**
+ 操作系统封装底层硬件并向上提供系统调用（会屏蔽底层硬件细节），高级编程语言会对系统调用进行封装，并向上提供库函数
+ 系统调用过程：用户传递系统调用参数、执行陷入指令（用户态），执行系统调用的相关服务程序（核心态），返回用户程序。
+ 陷入指令用于实现用户态下调用操作系统内核程序，执行之后会触发一个内终端，使CPU进入核心态。陷入指令是唯一一个只能在用户态执行而不能在核心态下执行的指令

## 进程与线程

### 进程

#### 定义

+ PCB：系统为每个运行的程序配置了一个数据结构，称为进程控制块（PCB)，用来描述进程的各种信息。
+ 进程实体：PCB、程序段、数据段三部分构成了进程实体，也叫进程映像，一般也可以简称为进程。
+ 创建线程实质上是创建进程实体中的PCB，撤销进程也是撤销PCB。**PCB是进程存在的唯一标志**
+ **进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位**。严格来说进程是动态的，进程实体是静态的，但一般可以认为进程实体就是进程。

#### 组成

+ 进程（实体）由PCB、程序段（代码）和数据段（需要的数据）构成
+ PCB包含进程基本信息（进程ID）、进程控制和管理信息（进程状态）、资源分配清单和相关处理信息（程序计数器）

#### 特征

+ 动态性，进程是程序执行过程，动态产生、变化和消亡
+ 并发性，内存中有多个进程实体，并发执行
+ 独立性，**进程是能独立运行、独立获得资源、独立接受支援调度的基本单位**
+ 异步性，进程执行速度不可预期，可能导致运行结果的不确定性
+ 结构性，结构相同

#### 进程状态与转换

##### 状态

+ 运行态，进程占用CPU，单核CPU同一时间只能有一个进程处于运行态
+ 就绪态，万事具备，只欠CPU，拥有了所有除了CPU外的资源
+ 阻塞态，因为某事件暂时不能执行，等待完成后才能进入就绪态
+ 创建态，分配资源，初始化PCB（新建线程时）
+ 终止态，回收资源和内存，删除进程PCB

##### 状态转化

+ 线程被创建，进入创建态
+ 获取到除了CPU外的资源，进入就绪态
+ 被调度上CPU运行进入运行态
+ 采用系统调用申请某种资源或者等待某个事件发生，进入阻塞态（进程的主动行为）
+ 申请的资源被分配或者等待的事情发生，回到就绪态（被动行为）
+ 当进程运行结束或运行遇到不可修复的错误或外界干扰，进入终止态

#### 进程通信

各进程拥有的内存地址空间相互独立，不能直接访问其他进程的内存空间

+ 共享存储，两个进程对共享空间的访问是**互斥的**
  + 基于数据结构
  + 基于存储区
+ 管道通信，用于连接读写进程的一个共享文件，本质是内存中开辟的一个大小固定的缓冲区
  + 管道只能实现**半双工**（一时间只能单向传输），要同时双向通信的话要设置两个管道
  + 数据以字符流的形式写入管道，当管道写满时，写进程被阻塞，等待数据被读走。读线程将所有数据都取走之后，管道变空，读进程被阻塞。
  + **管道没写满不能读，没读空也不能写**。
  + 数据一旦被读出，就从管道中被抛弃，读进程最多只有一个
+ 消息传递，数据交换通过格式化的消息为单位，进程通过操作系统提供的“发送/接受消息”两个原语来进行数据交换
  + 消息分成消息头和消息体，消息头包括发送进程ID、接收线程ID、消息类型、消息长度等等。
  + 分成直接通信和间接通信方式两种
    + 直接通信是直接将消息挂到接收线程的消息缓冲队列上（每个进程都有一个消息缓冲队列）
    + 间接通信是将消息发送到中间实体（信箱），接受进程去信箱中取

### 线程

#### 原因

+ 有的进程需要同时做很多事，而传统进程只能串行化地去执行一系列程序，为此引入了线程，来增加并发度
+ 进程中的多个线程可以同时执行，为此线程已经成为了程序执行流的最小单位

#### 概念

+ 线程可以理解为“轻量级进程”
+ 线程是一个基本的CPU执行单位，也是程序执行流的最小单位
+ 不仅仅进程之间可以并发，进程中的各个线程之间也可以并发，从而进一步提高了系统的并发度
+ 引入线程以后，进程只作为除CPU之外的系统资源的分配单元（打印机、内存地址空间等等）

#### 变化

+ 资源分配调度
  + 传统，进程是资源分配和调度的基本单位
  + 引入线程后，**进程只是资源分配的基本单位，线程变成了调度的基本单位**
+ 并发性
  + 传统，只能进程间并发
  + 引入线程，各线程之间也能并发，提高并发度
+ 系统开销
  + 传统，进程并发需要切换进程的运行环境，开销较大
  + 引入线程，若同一进程内的线程切换则不需要切换进程环境

#### 属性

+ 处理机调度的单位
+ 多CPU，各个线程可以占用不同的CPU
+ 线程拥有一个线程ID、线程控制块（TCB）
+ 线程也有就绪、运行、阻塞三种基本状态
+ 线程几乎不用有系统资源
+ 同一进程的不同线程共享进程的资源
+ 同一进程中的线程间通信，无需系统干预

#### 实现方式

+ 用户级线程
  + 由应用程序通过线程库来实现，所有线程管理工作都由应用程序负责，包括线程切换
  + 线程切换可以在用户态下完成，无需系统干预
  + 在用户看来，有多个线程；但对操作系统内核来看，只能看到用户进程，看不到线程
  + 用户级线程就是用户可以看到的线程
+ 内核级线程
  + 线程的管理由操作系统内核完成，包括线程调度、切换等
  + 线程的切换必须在核心态下完成
  + 操作系统可以看到的线程
+ 操作系统只看得见内核级线程，所以内核级线程才是处理机分配的单位

#### 多线程模型

+ 多对一：多个用户级线程对应一个内核级线程：
  + ![image-20201210200610894](https://gitee.com/ly10208/images/raw/master/img/20201210200610.png)
  + 优点：用户级线程的切换不需要切换到核心态，线程管理开销小
  + 缺点：一个用户级线程被阻塞，整个进程被阻塞，并发度不高，而且多个线程无法在多个核上并行运行
+ 一对一：
  + ![image-20201210200716926](https://gitee.com/ly10208/images/raw/master/img/20201210200717.png)
  + 优点：一个用户级线程被阻塞，其他线程还能继续执行，并发强，还可以运行在多个核上面
  + 缺点：一个用户进程占用多个内核级线程，用户级线程的切换需要由操作系统来完成，要切换到核心态，线程管理成本高、开销大
+ 多对多
  + ![image-20201210200905584](https://gitee.com/ly10208/images/raw/master/img/20201210200905.png)
  + 集二者之长

### 处理机调度

#### 概念

+ 按照某种算法选择一个进程并将CPU分配给他使用，以实现进程的并发执行

#### 三个层次

##### 高级调度

+ 按照一定的原则从后备队列中挑选一个，调入内存并分配资源，建立相应的PCB
+ **高级调度**（作业调度）是外存和内存之间的调度，每个作业之会发生一次

##### 中级调度

+ 将暂时不能运行的进程调至外存等待，等具备运行条件且内存空闲时，再调入内存。
+ 暂时调出内存等待的进程状态称为**挂起状态**，但是PCB不会被调出内存，会常驻内存，并记录进程数据在外存中的存放位置、进程状态等，操作系统通过内存管理这些继承。
+ **中级调度（内存调度）：**决定将哪个处于挂起状态的进程重新调入内存，每个作业可能发生多次
+ 挂起状态：
  + 就绪挂起：从就绪状态被挂起
  + 阻塞挂起：从阻塞状态被挂起，被激活会跳到就绪状态

##### 低级调度

+ **低级调度（进程调度）**：在就绪队列中选择一个为其分配CPU，频率会很高

![image-20201210200945094](https://gitee.com/ly10208/images/raw/master/img/20201210200945.png)

#### 进程调度时机

+ 需要进程调度
  + 当前进程主动放弃CPU（进程终止、异常、主动请求阻塞）
  + 当前进程被动放弃CPU（时间片用完、更紧急、更高优先级）

+ 不能进行进程调度
  + 处理中断的过程中
  + 进程在操作系统内核程序临界区中（就绪队列）
  + 原子操作过程中（原语）
+ 进程调度方式
  + 非抢占式，只允许进程主动放弃处理机，实现简单，系统开销小，但是无法及时处理紧急任务，适合早期批处理系统
  + 抢占式，可以剥夺进程占用CPU的权力，可以优先处理更紧急的进程，适合分时操作系统（分时片）、实时操作系统
+ 进程切换与调度
  + 狭义进程调度：从就绪队列中选择一个要运行的进程（可以是刚被暂定的进程或另一个进程）
  + 进程切换：一个进程让出CPU，另一个进程占用CPU的过程
  + 广义进程调度：选择一个进程和进程切换两个步骤
+ 进程切换工作
  + 对原来运行进程各种数据的保存
  + 对新进程各种数据的恢复

#### 调度算法的评价指标

+ CPU利用率：忙碌时间/总时间
+ 系统吞吐量：单位时间完成作业的数量
+ 周转时间：作业被提交到完成的时间（等待事件+执行时间）
+ 带权周转时间：作业周转时间/作业实际运行时间
+ 等待时间：等待CPU状态时间之和
+ 响应时间：提交到首次产生相应所用的时间

#### 调度算法

##### 先来先服务（FCFS)

+ 按到达的先后顺序，利用排队的思想，公平
+ 既可以用于作业调度也可用于进程调度
+ 非抢占式算法
+ 优点：公平、简单
+ 缺点：对短作业不利，对长作业有利

##### 短作业优先

+ 追求最少的平均等待时间
+ 非抢占，每次调度选择当前已到达的最短作业
+ 不太公平，可能会导致进程饿死

##### 最短剩余时间优先

+ 抢占，当有进程加入就绪队列中，或者当前进程放弃CPU时，需要重新调度
+ 不公平，也会导致进程饥饿

##### 高响应比优先

+ 每次调度计算所有进程的响应比（已等待时间+要求服务时间）/要求服务时间
+ 非抢占式算法
+ 综合考虑了作业/进程的等待事件和要求服务的时间，综合了先来先服务和短作业优先的优点
+ 不会导致饥饿

##### 时间片轮转（RR)

+ 公平的按照进程到达的时间，轮流让各个进程执行一段时间，如果时间片被用完，强制中断，换下一个进程，当前进程排队等待
+ 抢占式，利用系统时钟中断
+ 时间片的选择很重要，不能太大（沦为先来先服务），不能太小（进程切换过于频繁）
+ 优点：公平、响应快，适用于分时操作系统
+ 缺点：不区分紧急程度

##### 优先级调度算法

+ 可以让各个进程尽快得到相应
+ 非抢占、抢占
+ 系统进程优先用户进程、前台进程优先后台进程、IO型进程高于计算型进程
+ 有可能导致饥饿

##### 多级反馈队列调度算法

+ 可抢占
+ 设置多个就绪队列，各级队列优先级从高到低、时间片从小大大
+ 新进程达到先进入第一级队列，先来先服务分配时间片，若用完时间片，则进程进入下一级队列队尾
+ 被抢占的进程会重新放入原队列队尾

##### 总结

+ 先来先服务、最短作业时间、高响应比适用于批处理系统
+ 时间片轮转、优先级、堆积反馈队列适用于交互式系统

### 进程同步与互斥

##### 同步

+ 同步是保证进程推进顺序按我们所预期的顺序执行，克服进程之间的异步性

##### 互斥

+ 一个时间段内只允许一个进程使用的资源称为**临界资源**（物理设备、数据、内存缓冲区等）。
+ 对于临界资源的访问必须要互斥的进行，当前进程访问结束，释放该资源之后，另一个进程才能去访问临界资源
+ 进程互斥的实现
  + 进入区，检查是否可以进入临界区，可以则上锁
  + 临界区，访问临界资源的代码
  + 退出区，负责解锁
  + 剩余区，其余代码
+ 临界区进入原则：
  + 空闲让进，空闲就可以进
  + 忙则等待
  + 有限等待，保证不会饥饿
  + 让权等待，不能进入时，放弃CPU
+ 软件实现方法
  + 单标志法，**两个进程**在访问完临界区后会把使用临界区的权限转给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予。但是违背空闲让进原则
  + 双标志检查法，设置一个布尔型数据，标记各个进程进入临界区的意愿，之后才开始访问临界区
  + peterson算法，双标志的改进版，如果双方都想进入临界区，可以让进程尝试主动让对方先使用临界区
+ 硬件实现方法
  + 中断屏蔽，利用开中断和关中断实现对临界资源的访问，简单高效，但不适用于用户进程
  + TestAndSet指令，执行过程中不能被中断
  + Swap指令，执行过程中不能被中断，和TestAndSet差不多

#### 信号量

##### 概念

+ 一个用来表示某种资源数量的变量（可以是整型也可以是数据结构）
+ 用户进程可以通过一对原语（wait(s) , sign(s)）来对信号量进行操作，很方便实现进程同步与互斥
+ wait(S)、signal(S)可以记为P(S)、V(S)，实现系统资源的申请和释放。
  + 整型信号量（初始化、P操作、V操作）
    + wait(s)，检查资源数够不够（s<=0)，不够就一直等待，够的话就将s-1
    + signal(s)，使用完资源，释放资源
    + 会出现忙等待情况
  + 记录型信号量（一个剩余资源数，一个等待队列）
    + wait(s)，先减1，如果资源被分配完毕(<0)，阻塞当前进程，并挂载到d等待队列中
    + signal(s)，先加1，如果还有其他进程等待使用该资源，就从等待队列中唤醒一个进程
+ 设置一个信号量，初始值为资源的数量，若无空闲，则申请资源的进程需要等待别的进程释放资源后才能继续向下执行

##### 信号量实现互斥

+ 步骤
  + 分析并发进程的关键活动、划分临界区
  + 设置互斥信号量mutex，**初值为1**（临界区只能有一个线程访问）
  + 在临界区之前执行P操作
  + 在临界区之后执行V操作
+ 注意
  + 不同的临界资源要设置不同的互斥信号量（mutex1，mutex2)
  + PV操作成对出现

##### 信号量实现同步（保证两个操作的执行顺序）

+ 步骤
  + 设置同步信号量，**初值为0**
  + 前操作后执行V操
  + 后操作前执行P操作

+ 注意：
  + 为每一对前驱关系各设置一个同步变量
  + 前操作后，相应的同步变量执行V操作
  + 后操作前，相应的同步变量执行P操作

#### 生产者消费者问题

##### 概念

+ 缓冲区不空，消费者才能读，否则必须等待  （同步关系）
+ 缓冲区不满，生产者才能写，否则必须等待 （同步关系）
+ 缓冲区是临界资源，必须互斥等待                （互斥关系）

##### 信号量实现

+ ![image-20201210201205823](https://gitee.com/ly10208/images/raw/master/img/20201210201205.png)
+ 实现互斥的P操作一定要在实现同步的P操作之后，否则可能会引起死锁

#### 多生产者消费者问题

![image-20201210201543388](https://gitee.com/ly10208/images/raw/master/img/20201210201543.png)

+ ![image-20201028100440130](C:\Users\ly\Documents\typora\git\note\images.assets\image-20201028100440130.png)
+ 

#### 吸烟者问题

+ 可以生产多个产品的单生产者
+ ![image-20201210201605118](https://gitee.com/ly10208/images/raw/master/img/20201210201605.png)

#### 读者写者问题 

#### 管程

+ 管程是一种特殊的软件模块，有这些部分组成
  + 局部于管程的共享数据结构说明
  + 对该数据结构进行操作的一组过程
  + 共享数据的初始化
  + 管程名字
+ 管程类似于函数，拥有自己的变量、函数、数据初始化、函数名
+ 管程的特征
  + 管程中的数据只能被管程中的过程所访问
  + 一个进程只有**通过调用管程中的过程**才能访问管程中的数据
  + 每次只允许**一个进程**在管程内部执行某个内部过程
  + 由编译器实现各个进程互斥的进入管程中
  + 可在管程中设置条件变量以及等待/唤醒操作解决同步问题

### 死锁

#### 概念

+ 在并发环境下，各个进程因竞争资源而造成的一种**互相等待对方资源**，导致各进程都阻塞，无法向前推进的情况

#### 必要条件

+ 互斥，资源只能互斥的被使用
+ 不可剥夺，资源不能被其他进程抢走
+ 请求和保持，占有资源的同时继续请求其他资源
+ 循环等待（如果资源只有一个，发生循环等待，必然死锁，否则不然）

#### 什么时候

+ 对不可剥夺资源的竞争
+ 进程推进顺序非法
+ 信号量使用不当
+ 总之，对不可剥夺资源的不合理分配，可能导致死锁

#### 处理策略

+ 预防，破化四个必要条件中的一个或多个
+ 避免，使用某种方法防止系统进入不安全状态（银行家算法）
+ 检测和解除，检测出死锁，并解除

#### 预防死锁

+ 互斥，将必须互斥使用的资源改成允许共享使用，比如spooling技术，但并不是所有的资源都可以改
+ 不可剥夺
  + 新请求的资源得不到满足，则主动释放保持的所有资源
  + 由操作系统协助，强行剥夺所需要的资源（要考虑优先级）
  + 缺点：复杂、容易饥饿、资源请求释放成本高
+ 请求保持，采用静态分配的方法，在进程运行前一次申请完他所需要的全部资源，在资源未满足前，不让他投入运行
  + 缺点：资源利用率极低
+ 循环等待，顺序资源分配，给资源编号，每个进程必须按照顺序请求资源
  + 缺点：不方便新增设备
  + 进程实际占用资源顺序与编号顺寻不一致，导致资源浪费
  + 变成麻烦

#### 避免死锁（银行家算法）

+ 安全状态
  + 安全序列：如果系统按照这种序列分配资源，则各个进程都能顺利完成。
  + 只要能找到一个安全序列，系统就是安全状态，安全状态可以有多个
  + 系统处于安全状态，一定不会发生死锁；系统处于不安全状态，可能发生死锁
+ 银行家算法
  + 核心思想：在资源分配前先预测这次分配是否会导致系统进入不安全状态，以此判断是否答应资源分配请求

#### 死锁检测与解除

+ 检测：用某种数据结构保存资源请求和分配信息，检测是否发生死锁

+ 解除：
  + 资源剥夺
  + 撤销进程
  + 进程回退
+ 解除原则
  + 优先级低的
  + 已执行时间短的
  + 还需时间长的
  + 已占用资源少的
  + 批处理式的

## 内存管理

### 功能

+ 内存空间的分配与回收
+ 从逻辑上对内存空间进行扩充
+ 逻辑地址与物理地址的转换
  + 绝对装入（编译器负责地址转换）（无操作系统）
  + 可重定位装入（装入程序负责进行地址转换）（批处理系统）
  + 动态装入（运行时才进行地址转换）（现代操作系统）
+ 内存保护，让各个进程只能访问自己的内存空间
  + 在CPU设置一对上下寄存器
  + 采用重定位寄存器（基址寄存器）、界地址寄存器（限长寄存器）进行判断

### 内存空间的扩充

#### 覆盖技术

+ 将程序分成多个段，常用的段长驻内存，不常用的需要时才调入内存
+ 内存中分为一个“固定区”和若干个“覆盖区”
+ 长驻内存的段放在固定区，调入后不再调出，直到运行结束
+ 不常用的段放在覆盖区，需要用时调入内存，用不到时调出内存
+ 但是必须由用户声明覆盖结构，对用户不透明，增加编程负担

#### 交换技术

+ 内存紧张时将某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存
+ 在具有对换功能的操作系统中，磁盘空间分成文件区和对换区，进程被移动到磁盘中的对换区
+ 优先换出阻塞进程

### 内存空间的分配与回收

内存分成用户区和系统区

内部碎片：分配给进程的，但是没有用到的的空间

外部碎片：空闲分区太小，而不能分配给进程的空间

#### 连续分配

##### 单一连续分配

+ 内存分成系统区和用户区
+ 内存中只能有一道用户程序，不支持并发
+ 优点：实现简单、无外部碎片，可用覆盖技术扩充内存
+ 缺点：只能用于单用户、单任务的操作系统，有内部碎片，利用率低

##### 固定分区分配

+ 分区大小相等，缺乏灵活性
+ 分区大小不等
+ 通过分区说明表来记录内存分配的情况
+ 优点：实现简单，无外部碎片
+ 缺点：用户程序太大，得用覆盖技术，有内部碎片

##### 动态分区分配

+ 不预先划分内存区域，当程序装入内存时，根据进程大小动态创建分配连续分区
+ 可以用空闲分区表或空闲分区链来记录内存空闲情况
+ 动态分区算法，从空闲空间中分配内存给进程
+ 动态分区没有内部碎片，但是有外部碎片
+ 外部碎片可以通过紧凑技术来解决，通过把空闲的空间移动合并成一块大的内存

###### 动态分区算法

+ 首次适应算法：每次从低地址开始查找，找到第一个能满足大小的空闲分区
+ 最佳适应算法：将空闲分区从小到大排序，找到大小能满足要求的第一个空闲分区，但是会产生很多的外部碎片
+ 最坏（大）适应算法：与最佳适应算法恰恰相反，将空闲分区从大到小排序，找到大小能满足要求的第一个空闲分区，但大分区容易用完，算法开销大
+ 临近适应算法：由首次适应演变而来，每次从上次查找结束为止开始查找，

#### 非连续分配

##### 分页存储管理

###### 概念

+ 将内存空间分成一个又一个大小相等的分区（比如每个分区4kB），
+ 每个分区就是一个**页框**，或页帧、内存块、物理块。每个页框有一个编号，叫页框号，从0开始
+ 将用户进程的地址空间也分成与叶匡大小相等的一个个区域，称为**页**，或者页面，每个页面也有一个编号，即页号，页号也从0开始。
+ 操作系统以页框为单位为各个进程分配内存空间，进程的每个页面分别放入一个页框中，也就是说进程的页面和内存的页框有着一一对应的关系。各个页面不需要连续存放

###### 地址转换：

+ 页号等于逻辑地址/页面长度
+ 页内偏移量等于逻辑地址%页面长度
+ 物理地址 = 页面起始地址 + 页内偏移量
+ 操作系统会为每个进程创建一个**页表**，存放页号与页框号的对应关系

###### 基本地址变换机构

+ 系统中设置一个**页表寄存器PTR**，存放页表在内存中的起始地址F和页表长度M（几个页表）。
+ 页表的起始地址和长度放在PCB中，当进程被调用时，操作系统会把它们放到页表寄存器中
+ 页表项长度指的是，页表中的每个页表项占用存储空间的大小（3个字节就可以，但一般采用**4个字节**，使得每个页面可以装的下一个页表项）
+ 页表长度指的是，页表中页表项的个数
+ 页面大小指的是，一个页面占用多大的空间
+ 内存中查询数据需要访问两次内存，一次访问页表项，另一次访问数据

###### 具有快表机制的变换机构

+ 背景
  + 时间局部性：如果执行了某条指令，不久后这条指令很可能再次执行（循环）
  + 空间局部性：程序访问了某个存储单元，不久后，很可能访问其附近的存储单元（很多数据在内存中连续存放）
  + 由于局部性原理，很可能多次访问同一个页表项。
+ 快表
  + 又称联想寄存器（TLB），是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程（与此对应，内存中的表项被称为慢表）
  + 下次访问时先去快表中查询，如果没命中的话，就重新去内存中找，找到后将其存储到快表
+ ![image-20201210201847172](https://gitee.com/ly10208/images/raw/master/img/20201210201847.png)

##### 单级页表

###### 存在问题

+ 页表必须连续存放，当页表很大时，会占用很多连续的叶匡
+ 没必要让整个页表常驻内存，局部性原理

###### 解决

+ 将页表进行分组，是每个内存块中恰好可以放入一个分组
+ 页框大小4KB，每个页表项4B，可以将1K个连续的页表项分成一组，每组占用一个页框，然后离散放入页框中
+ 虚拟存储技术，使用时就调入内存

###### 两级页表

+ 解决页表连续存放的缺点
+ 二级页表：将页表项分组之后，每组一个编号，叫页表号
+ 一级页表：存放二级页表页表号与页框的对应关系

##### 分段存储管理

###### 概念

+ 按程序自身的逻辑关系划分成若干段，每个段都有一个段名，每段从0开始编址，每个段的长度可以不同
+ 将内存也按段进行分配，每个段占用连续地址空间，各段之间可以不相邻
+ 分段系统的逻辑地址结构由段号（段名）和段内地址（段内偏移量）来表示
+ 操作系统为每个进程建立一个段表，存储程序段号、段长和内存中的起始地址

###### 地址变换

+ 由逻辑地址得到段号、段内地址
+ 检查段号是否越界
+ 由段号找到对应的段表项
+ 根据段表项中的段长判断，逻辑地址的段内地址是否越界
+ 根据段表项的起始地址和逻辑地址的段内地址，得到最终物理上地址
+ 访问目标单元

##### 分段与分页对比

+ ![image-20201210201945876](https://gitee.com/ly10208/images/raw/master/img/20201210201946.png)
+ 分段比分页更容易实现信息的共享和保护，可以将一整个段作为信息共享
+ 分页和分段访问逻辑地址都需要两次访问内存，分段存储也可以引入快表机制
+ ![image-20201210202052048](https://gitee.com/ly10208/images/raw/master/img/20201210202052.png)

##### 段页式管理

###### 概念

+ 将进程按照逻辑模块分段，再将各段分页（每个页面4KB）
+ 一个进程对应一个段表，一个段号对应一个页表
+ 将内存分成大小相等的页框
+ 段页式的逻辑结构由段号、页号、页内地址（偏移量）组成
+ 每个段对应一个段表项，各段表项长度相同，由段号、页表长度（该段被分成几个页）、页表存放地址构成
+ 每个页对应一个页表项，各页表项长度相同，由页号，页面存放内存块组成

#### 传统存储管理

+ 连续分配，单一连续、固定分区、动态分区
+ 非连续分配，分页，分段，段页
+ 缺点：
  + 一次性，必须一次性装入内存后才能运行（大作业无法运行，多道程序并发度下降）
  + 驻留性，一旦作业被装入内存，及那个长驻内存，直到作业结束（内存驻留暂时用不到的数据）

### 虚拟内存

#### 概念

+ 基于局部性原理，将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，让程序开始执行
+ 执行过程中，当访问信息不在内存中时，由操作系统负责将所需的信息从外存调入内存，然后继续执行
+ 若内存空间不够，由操作系统将内存中暂时用不到的换出内存
+ 在操作系统的管理下，似乎有一个比实际内存大的多的内存，这就是虚拟内存

#### 特征

+ 多次性
+ 对换性
+ 虚拟性

#### 注意

+ 虚拟内存的最大容量是由计算机的地址结构（CPU寻址范围）确定的（32位CPU 4GB)
+ 虚拟内存的实际容量是min(内外存之和，CPU寻址范围)

#### 实现

+ 请求分页存储管理
+ 请求分段存储
+ 请求段页式存储管理
+ 注意
  + 虚拟内存的实现需要建立在离散分配的内存管理方式下
  + 操作系统需要提供请求调页（段）和页面（段）置换功能

#### 请求分页管理

##### 页表机制

###### 页表

+ 包含：页号，内存块号、状态位、访问字段、修改位、外存地址  六大部分构成

   说明：

+ 状态位，标志该页面是否调入内存
+ 访问字段，记录上次访问时间或访问次数，作为评判页面换出的指标
+ 修改位，标志页面调入后是否修改过

###### 缺页中断机构

+ 当访问的页面不存在时，产生一个**缺页中断**，该进程阻塞；操作系统的缺页中断程序处理该中断
+ 如果内存中右空闲，则为进程分配一个空闲块，将所缺页面装入，并修改页表项
+ 如果没有空闲快，由**页面置换算法**选择一个页面淘汰，若该页面在内存中被修改过，将其回写外存，未修改的页面不用写回外存

#### 页面置换算法

##### 最佳置换算法（OPT）

+ 每次选择以后永不使用或者在**最长时间内不再被访问**的页面
+ 可以保证最低的缺页率，但是必须知道接下来的页面访问列表
+ 但操作系统无法提前预知页面访问序列，故最佳页面置换是不可实现的

##### 先进先出置换算法（FIFO)

+ 每次淘汰最早进入内存的页面
+ 实现简单，可能出现Belady异常（内存块多，缺页中断也多），与进程运行实际规律不适应，算法性能差

##### 最近最久未使用置换算法（LRU）

+ 选择最近最久未被使用的页面淘汰
+ 在页表项中，用访问字段记录该页面子访问以来所经历的时间
+ 该算法实现需要专门的硬件支持，虽然算法性能好，当实现困难，开销大

##### 时钟置换算法（CLOCK）

+ 又称最近未使用算法（NRU）
+ 简单CLOCK
  + 为每个页面设置一个访问位，再将内存中的页面链接成一个循环队列，当某个页面被访问时，其访问位为1
  + 需要淘汰页面时，只需检查页的访问位，如果是0，就将该页换出；如果是1，就改成0，检查下一个页面
  + （若第一轮全是1，就需要第二轮扫描），最多两轮扫描
+ 改进型CLOCK
  + 除了考虑最近未被访问外，还要考虑页面有无被修改过。其他条件相同时，优先淘汰没有修改过的页面。
  + 设置两个标志位，（访问位，修改位） = （0，0）（表示 未访问未修改）
  + 步骤
    + 第一轮：找到第一个未被访问且未被修改的页面（0，0），不修改任何标志位
    + 第二轮：第一轮扫描失败，重新扫描，找到第一个未被访问但被修改的页面（0，1），将扫描过的帧访问位设为0
    + 第三轮：若第二轮失败，则重新扫描，找到第一个未被访问且未被修改的页面（0，0），不修改标志位
    + 第四轮：若第二轮失败，则重新扫描，，找到第一个未被访问但被修改的页面（0，1）
  + 说明：
    + 由于第二轮将扫描到的帧的访问位改成0，所以第三轮或第四轮必有命中
    + 最多会进行四轮扫描

#### 页面分配策略

##### 驻留集

+ 请求分页管理中给进程分配物理块的集合
+ 太大导致多道程序并发度下降、资源利用率低；太小导致缺页频繁
  + 固定分配，驻留集大小固定
  + 可变分配，可适当增加或减小
  + 内部置换，只能与自己的物理块置换
  + 全局置换，可与操作系统或其他进程的物理块置换

##### 调入调出位置

对换区读写速度快，采用连续分配的方式

文件区读写速度慢，采用离散分配方式

+ 对换区足够，页面的调入调出都是在内存与对换区之间进行
+ 对换区不够，凡是不会被修改的从文件区调入，对于可能被修改的，换出是写到对换区，下次从对换区调入
+ UNIX方式，未使用的页面，从文件区调入，换出到交换区，下次需要时从对换区调入

##### 抖动（颠簸）现象

+ 刚换出的页面马上要换入内存，刚换入的内存又要换出内存，这种频繁的页面调度行为称为抖动（颠簸）
+ 主要原因，分配给进程的物理块不够
+ 工作集：
  + 指的是某段时间间隔里，进程实际访问页面的集合，操作系统会通过**窗口尺寸**计算出工作集
  + 驻留集一般要大于工作集

## 文件系统

### 基本知识

#### 属性

+ 文件名
+ 标识符（操作系统用于区分文件的标识符）
+ 类型
+ 位置，文件按存放的路径
+ 保护信息，对文件进行保护访问的控制程序

#### 文件内部组织

+ 无结构文件（txt)，由二进制或字符流组成，又称“流式文件”
+ 有结构文件（excel)，由一组相似的记录组成，又称“记录式文件”，记录是一组相关数据项的集合

#### 文件存放

+ 外存也会被分成一个一个“块/磁盘块/物理块”。每个块的大小是相等的，每块一般包含2的整数幂个地址（2^10=1KB)
+ 文件的逻辑地址也可以分成（逻辑块号+块内地址）
+ 操作系统以块为单位为文件分配存储空间,也是以块为单位读写的

### 文件的逻辑结构

有结构文件，由一组相似的记录项组成，又称为记录式文件

#### 顺序文件

+ 文件中的记录一个接一个的（在逻辑上）顺序排列，记录可定长可不定长。各个记录可以物理上顺序存储（数组），也可链式存储（链表），默认顺序存储
  + 串结构
    + 记录之间的顺序与关键字无关，通常按记录的时间来排序
  + 顺序结构
    + 记录之间的顺序按关键字排序
+ 定长记录的的顺序存储，可以实现随机存取；不定长不可以（必须从前到后遍历）

#### 索引文件

+ 创建一个索引表，文件的每个记录对应一个表项，各个记录不用顺序存储，便于增删
+ 索引表是定长记录的顺序文件，可支持随机存取

#### 索引顺序文件

+ 将多条记录合并成组，每组对应一个索引表项
+ 先查到分组，分组内顺序查找

### 文件目录

##### 文件控制块（FCB）

+ 文件控制块的有序集合称为“文件目录”，一个FCB就是一个文件的目录项，其中包含了文件的基本信息（**文件名、物理地址**、逻辑结构、物理结构等）、存取控制信息（读写权限）、使用信息（文件创建修改时间）
+ **FCB**主要是为了实现用户**“按名存取”**的功能，所以文件名和物理地址最重要

##### 目录结构

+ 单级目录机构
  + 整个系统就创建了一张目录表
  + 实现了按名存取，但文件不能重名
+ 两级目录
  + 主文件目录（记录用户）、用户文件目录
  + 不同用户文件可以同名
+ 多级目录
  + 树形目录，各级目录间用“/”
  + 不同目录下的文件可以重名
  + 便于分类，但不利于共享
+ 无环图目录
  + 不同的文件名可以指向同一个文件
  + 需要为每个节点设置一个共享计数器

+ 索引节点（FCB改进）
  + 利用文件名查找文件时，在需要用到文件名这个信息，只有匹配时才需要其他信息
  + 可以考虑让目录表瘦身，目录项中只包含文件名和索引节点指针，其他信息都放到索引表中
  + 由于目录像长度减小，每个磁盘块可以放更多的目录，检索文件时磁盘IO也会减少

### 文件物理结构

文件如何放到外存中

#### 连续分配

+ 每个文件在磁盘上占有连续的块
+ 在文件目录中记录存放的起始块号和长度，
+ 用户可以通过文件的  逻辑块号和块内地址  来获取文件
+ 优点：支持随机访问和顺序访问、由于磁盘结构，顺序读写速度最快
+ 缺点：文件不便于扩展、会产生难以利用的磁盘碎片（紧凑技术）

#### 链接分配

采取离散分配的方式，可以为文件分配离散的磁盘块，默认隐式

##### 隐式链接

+ 目录中记录了文件存放的起始块号和结束块号
+ 每个磁盘块中都有指向下一块的指针
+ 只能顺序访问、不支持随机访问
+ 方便扩展，不会产生碎片

##### 显式链接

+ 目录中只需要记录文件的起始块号
+ 将用于连接文件物理块的指针显式的都放到一张表中，即文件分配表（FAT）
+ 文件分配表开机读入内存，并长驻内存
+ **一个磁盘只需要一张FAT**，FAT自身连续存储与磁盘中
+ 很方便扩展，不存在碎片、支持随机读取，地址转换时不用访问磁盘，效率高
+ 但是文件分配表会占用一定的磁盘空间

#### 索引分配

+ 为**每个文件**建立一个**索引表**，索引表中记录了各逻辑块对应的物理块
+ 索引表存放的磁盘块叫索引块，文件数据存放的磁盘块叫数据块
+ 目录中会记录文件的索引块
+ 当索引表较大，一个索引块无法存入，解决方案
  + 链接方案：将多个索引块链接起来（必须一个块一个块的读，磁盘读写次数多）
  + 多层索引：是第一层索引块指向第而层的索引块（各层索引表的大小不能大于一个磁盘块），小数据也需要多级索引效率低
  + 混合索引：顶级索引表既包含直接地址，又包含一级索引块，对小文件来说磁盘读写次数少

![image-20201210202120027](https://gitee.com/ly10208/images/raw/master/img/20201210202120.png)

### 文件存储空间管理

#### 存储空间的划分和初始化

+ 磁盘分区，可以将物理磁盘空间划分成多个卷（逻辑盘、逻辑卷）
+ 一个逻辑卷可以分成
  + 目录区，存放文件的目录信息（FCB）和用于管理磁盘存储空间管理的信息
  + 文件区，存放文件数据

#### 存储空间管理

##### 空闲表法

+ 适用于连续分配方式

+ 有一个空闲表，记录第一个空闲磁盘块号和空闲磁盘块
+ 可以采用首次适应、最佳适应、最坏适应等

##### 空闲链表法

+ 空闲盘块链，
  + 将各个盘块链接在一起组成空闲链
  + 每个盘块保存指向下一个盘块的指针
+ 空闲盘区链，
  + 以盘区（连续空闲盘块组成）为单位组成空闲链
  + 盘区第一个盘块保存盘区的长度和下一盘区的指针
+ 操作系统保存链头链尾指针

##### 位示图法

+ 将盘块号用（字号，位号）来表示，盘块号=字号*16+位号，
+ 用一张二维表格来表示
+ 表格中”0“表示空闲，”1“表示已分配

##### 成组链接法

+ 将100个磁盘块绑到一起称为大块
+ 适合大型文件系统

### 文件共享

#### 基于索引节点的共享（硬链接）

+ 索引节点是文件目录的精简版本，检索文件时只需要文件名，所以可以将除了文件名之外的其他信息放入索引节点中，目录项只用包含文件名、索引节点指针
+ 索引节点中设置一个链接计数变量count，表明有几个用户目录链接到本索引节点
+ 用户删除文件时，只是删除自己的目录项中的该条记录，并将count-1
+ 当count=0时，才会删除该文件

#### 基于符号链的共享（软链接）

+ 新建一个Link类型的文件，记录想要共享文件的存放路径，相当于win快捷方式
+ 操作系统会通过路径一层层查找到该文件
+ 访问共享文件时要查询多级目录，会有多次磁盘IO

### 文件保护

#### 口令保护

+ 在FCB或索引节点中存放文件的口令
+ 口令时间开销空间开销都小，但口令存放在系统内部不安全

#### 加密保护

+ 对文件的数据进行加密，访问时要正确的密码
+ 保密性强，不需要在系统中存储密码；编码解码要时间开销

#### 访问控制

+ FCB或索引节点中增加一个访问控制表（ACL），记录用户的权限
+ 当用户数过多时，可以以组为单位，标记各个组的权限来精简访问控制表
+ 实现灵活，可实现复杂的文件保护功能

### 文件系统层次结构

+ ![image-20201030145016873](https://gitee.com/ly10208/images/raw/master/img/20201210202313.png)

+ ![image-20201210202901795](https://gitee.com/ly10208/images/raw/master/img/20201210203106.png)

  

### 磁盘

#### 磁盘、磁道、扇区

+ 磁道：磁盘被划分成一个又一个的同心圆，一个圆就是一个磁道
+ 一个磁道被划分成若干个扇区，每个扇区就是一个”磁盘块“（扇区存放大小相同）
+ 最内测扇区的面积最小，所以数据密度最大

#### 读写过程

+ 把磁头移动到想读扇区的磁道，盘面旋转，对应的扇区对准磁头，才能读写

#### 磁盘读写时间

+ 寻道时间（启动磁头臂，移动磁头）
+ 延迟时间（旋转磁盘，扇区对准磁头的时间）
+ 传输时间（从磁盘读出或写入所经历的时间）
+ 延迟时间和传输时间都与磁盘转速有关

#### 磁盘调度算法

##### 先来先服务

+ 根据进程请求访问磁盘的先后顺序进行调度
+ 公平

##### 最短寻找时间优先

+ 优先处理与当前磁头最近的磁道，只能局部最优，不保证全局最优
+ 性能好，平均寻道时间短，可能饥饿（磁头在一小块区域来回移动）

##### 扫描算法

+ 只有磁头移动到最外侧才能向内移动，移动到最内侧才能向外
+ 寻道时间短，不会饥饿
+ 但必须到达最边上的磁道才能改变磁头方向，实际上不用
+ 磁道响应频率不均匀（两次访问同一磁道的时间不同）

##### LOOK算法

+ 扫描算法改进，在磁头移动方向没有其他请求时，可以立即改变磁头方向
+ 解决扫描算法必须到达最边上的磁道才能改变磁头方向缺点

##### 循环扫描算法（C-SACN算法）

+ 只有磁头向某个固定方向移动时，才能处理访问请求，返回时直接快速移动不接受处理请求
+ 解决扫描算法磁道响应频率不均匀

##### C-LOOK算法

+ C-SCAN和LOOK算法的综合版

#### 减少延迟时间

##### 交替编号

+ 磁头读完一个扇区后，需要一定的的准备时间才能继续读下一个扇区
+ 可以让逻辑上相邻的扇区在物理上有一定的间隔，这样就可以连续读

##### 磁盘地址结构设计

+ 磁盘的物理地址是柱面号、盘面号、扇区号，而不是盘面号、柱面号、扇区号
+ 这样设计，在**读取连续的磁盘块时，可以减少磁头移动消耗的时间**
+ 比如说读连续地址（00，00，00）---（00，01，11）
  + 使用先盘后柱时，读完（00，00，11）再读（00，01，00）时，需要更换柱面，依旧需要移动磁头臂
  + 而先柱后盘时，读完（00，00，11）再读（00，01，00）时，只需更换盘面，无需移动磁头臂

##### 错位命名

+ 所有的盘面同步转
+ 让相邻盘面相对位置的扇区命名错开
+ 原理与交替编号相同

#### 磁盘管理

##### 磁盘初始化

+ 进行低级格式化（物理格式化），将磁道划分为扇区，一个扇区分成头、数据区、尾三部分。头尾不存放用于管理的数据结构
+ 磁盘分区，每个分区由若干个柱面组成
+ 逻辑格式化，创建文件系统。创建文件系统的根目录、初始化存储空间管理所用的数据结构（空闲分区表）

##### 引导块（启动分区）

+ 计算机开启时需要进行一系列初始化工作，这些初始化工作指通过执行初始化程序（自举程序）完成的
+ 自举程序可以放到ROM中，但不能更改，所以ROM中只放入很小的自举装入程序，完整自举程序放到磁盘的启动快（引导块）
+ 拥有启动分区的磁盘被称为启动磁盘或系统磁盘（C盘）

##### 坏块管理

+ 对简单的磁盘，在逻辑格式化时，标记坏扇区（在FAT表上标明），对操作系统不透明
+ 对复杂磁盘，磁盘控制器维护一个坏块链表，在低级格式化时就对坏链初始化；也会保留一些备用扇区替换坏块（**扇区备用**），对操作系统透明

## 设备管理

### IO设备

#### 概念

+ 控制数据的输入输出
+ UNIX会将外部设备抽象为一种特殊的文件，用与文件操作相同的方式进行操作

### IO控制器

#### 功能

+ 接受识别CPU发出的命令（IO设备中的控制寄存器）
+ 向CPU汇报设备状态 （IO设备中的状态寄存器）
+ 数据交换  （IO设备中的数据寄存器）
+ 地址识别  （区别IO设备中的各个寄存器

#### 组成

+ CPU与控制器之间的接口（实现控制器与CPU之间通信）
+ IO逻辑（负责识别CPU发出的命令，并向设备发送命令）
+ 控制器与设备间接口（实现控制器与设备通信）

#### 寄存器编制方式

+ 内存映射，控制器的寄存器与内存统一编址（内存0-N,寄存器N+1---)，可以采用内存的操作来控制寄存器的操作
+ 独立编址，控制器的寄存器独立编址（需要设置专门的指令来操作控制器）

### IO控制方式

#### 程序直接控制

+ **轮询**
+ CPU向IO发出读命令；轮询检查状态寄存器的状态；当状态已就绪时，从IO模块中读取数据放到CPU寄存器中；向内存中写入数据；循环
+ 在等待IO完成的过程中，CPU需要不断的轮询
+ **每次读写一个字**
+ 优点：实现简单
+ 缺点：CPU和IO设备只能串行工作，CPU要一直轮询，利用率低

#### 中断驱动控制

+ 引入中断机制，将轮询检查改成中断，当前进程挂起，CPU分配其他进程，当IO完成后，控制器会向CPU发送信号
+ 读写单位：每次一个字

#### DMA控制

+ 直接存储器存取（DMA）
+ 数据传送**单位是块**，不再是一个字
  + （还是需要DMA一个字一个字读写）
  + 每次读写的是连续的多个块，写内存也连续排布
+ 数据直接从设备流向内存，不再需要CPU的中转
+ 只有在数据读写开始或终止时，才需要CPU参与
+ 优点：数据传输以”块“为单位，数据不需要CPU的中转
+ 缺点：CPU每发一条IO指令，只能读写连续的数据块；如果要读写离散的数据块，需要CPU发出多条IO指令

#### 通道控制

+ 一种硬件，弱鸡版CPU，可识别一系列通道指令
+ CPU向通道发出IO指令，指明通道程序（任务清单）的位置
+ 数据传输单位，**一组数据块**
+ 优点：CPU、通道、IO可并行工作，资源利用率高
+ 缺点，实现复杂、需要专门的通道硬件支持
+ 一个通道可以管理多个控制器、一个控制器可以管理多个设备

#### 总结

![image-20201031125859199](https://gitee.com/ly10208/images/raw/master/img/20201210203513.png)

### IO软件层次结构

#### 结构

+ 用户层、设备独立性软件、设备驱动程序、中断处理程序、硬件
+ 用户层实现与用户交互的接口
+ 设备独立性软件（设备无关性软件）
  + 向上层提供接口
  + 设备保护
  + 差错处理
  + 设备分配与回收
  + 数据缓冲区管理
  + 建立逻辑名到物理设备名的映射关系（逻辑设备表（LUT））
  + ![image-20201031130528747](https://gitee.com/ly10208/images/raw/master/img/20201210203446.png)
+ ![image-20201031130845845](https://gitee.com/ly10208/images/raw/master/img/20201210203452.png)

#### 核心子系统

+ 设备独立性软件、设备驱动程序、中断处理程序，属于操作系统内核部分，也称IO核心子系统
+ 设备驱动程序、中断处理程序会直接与底层硬件打交道

##### 假脱机系统（SPOOLing)

+ 本质是在用户层实现的
+ 脱机技术：脱离主机的控制进行输入输出操作，借助外围控制机将数据从纸带机输入到磁带机，或将数据从磁带机输入到纸带机
+ 假脱机技术：利用软件模拟脱机技术
  + 借助输入进程将数据读到输入井，利用输出程序将数据从输出井输出（输入输出井位于磁盘）
  + 同时也会在内存中设置输入缓冲区和输出缓冲区，暂存输入设备输入的数据，和即将输出输出设备的数据
  + ![image-20201031132346365](https://gitee.com/ly10208/images/raw/master/img/20201210203650.png)
  + 可以将独占设备变成共享设备

##### 设备分配与回收

+ 设备分配算法
  + 安全分配算法，为进程分配一个设备后就将进程阻塞，此次IO完成后才唤醒进程
    + 一时间一个进程只能使用一个设备
    + 破坏请求和保持的条件，不会死锁
    + 但CPU和IO设备只能串行工作
  + 不安全分配算法，进程发出IO请求后，系统为其分配IO设备，进程可继续执行，还可以发出新的IO请求，只有某个IO请求得不到满足才将该进程阻塞
    + 一个进程可以使用多个设备
  + 静态分配，运行前设备分配好
  + 动态分配，运行时动态申请设备
+ 设备分配管理数据结构
  + 一个通道可以管理多个控制器、一个控制器可以管理多个设备
  + 设备控制表（DCT）：系统为每个设备分配，用于记录设备情况
    + ![image-20201031140204594](https://gitee.com/ly10208/images/raw/master/img/20201210203654.png)
  + 控制器控制表（COCT），每个设备控制器，操作系统根据COCT的信息对控制器进行操作和管理
    + ![image-20201031140350523](https://gitee.com/ly10208/images/raw/master/img/20201210203938.png)
  + 通道控制表（CHCT)，每个通道，操作系统根据CHCT的信息对通道进行操作和管理
    + ![image-20201031140427014](https://gitee.com/ly10208/images/raw/master/img/20201210204504.png)
  + 系统设备表（SDT），记录系统中**全部设备**的情况，每个设备对应一个表目
    + 一条表目包含：设备类型（打印机），设备标识符（物理设备名）、DCT（设备控制表）、驱动程序入口
+ 设备分配的步骤
  + 根据进程请求的物理设备名查找SDT
  + 根据SDT查找DCT，如果设备空闲，就分配给该进程，否则就将该进程PCB挂到设备等待队列
  + 根据DCT找到COCT，如果控制器空闲，就分配给该进程，否则就将该进程PCB挂到设备等待队列
  + 根据COCT找到CHCT，如果通道空闲，就分配给该进程，否则就将该进程PCB挂到设备等待队列
  + 只有当设备、控制器、通道三者都分配成功时，此次设备分配才算成功，之后便可以启动IO设备进行数据传输
+ 缺点：
  + 必须使用物理设备名，若更换物理设备，则无法工作；
  + 而且只能分配给当前设备，不能分配给其他同类型设备
+ 建立逻辑设备名到物理设备名的映射，便可以通过逻辑映射名查找SDT

##### 缓冲区管理

+ 一个存储区域，可用寄存器，也可以用**内存**充当

+ 作用：

  + 缓和CPU与IO设备速度不匹配
  + 减少CPU的中断频率
  + 解决数据粒度不匹配（数据传输以字、块为单位）
  + 提高CPU与IO的并行度

+ 特征

  + 缓冲区的大小是一个块
  + 缓冲区非空不能写，非满不能读
  + 单缓冲区只能实现任意时刻单向传输，要想同时双向需要设置两个缓冲区

+ 缓冲区类型

  + 单缓冲

  + 双缓冲

  + 循环缓冲区，多缓冲区成环，维护in指针（下一个可写）和out指针（下一个可读）

  + 缓冲池，很多个缓冲区组成，维护空缓冲队列、满输入队列、满输出队列

    + ![image-20201031143302272](https://gitee.com/ly10208/images/raw/master/img/20201210204225.png)

      



































